[{"title":"","date":"2017-05-12T13:31:25.756Z","path":"2017/05/12/leetcode17_5_12/","text":"title: LeetCode95、99date: 2017-05-12 21:06:46tags: [算法,leetcode] LeetCode 95这道题是和不同的二叉树的个数问题相关的(Unique Binary Search Trees),不同之处在于问题一中只要求统计个数，而问题二中需要构造出所有的二叉树。问题一用DP的方法是很容易实现的，是因为二叉树固定数字生成的二叉树是固定的，一个二叉树的种类由它可能的左子树和右子树数目决定的，所以DP轻松解决。问题二我陷入了用DP的思路，后来事实证明DP也是可以完成的。但是我看到的更好的解法是用自上而下递归的策略。调用helper(1,n)完成。vector&lt;TreeNode*&gt; helper(int start, int end) { vector&lt;TreeNode *&gt; results; if (start&gt;end) { results.push_back(NULL); return results; } for (int k = start; k &lt;= end; k++) { vector&lt;TreeNode *&gt; left = helper(start, k - 1); vector&lt;TreeNode *&gt; right = helper(k + 1, end); for (int i = 0; i&lt;left.size(); i++) { for (int j = 0; j&lt;right.size(); j++) { TreeNode * root = new TreeNode(k); root-&gt;left = left[i]; root-&gt;right = right[j]; results.push_back(root); } } } return results; } 同时也说明一下另外一种解法。我们对于某一次生成有如下考虑 新的根只需要把之前的根作为自己的左子树。 新的节点不作为根加入之前的树，由于它是最大的肯定是一路向右。所以可以遍历之前的树，对于每一棵树，从根的右节点逐步下移，截断处剩下的部分作为新节点的左子树，直到最右侧的叶子节点为止。 LeetCode 99题意描述：一个二叉树中的两个节点由于某些错误被交换了，找出他们并恢复二叉树。（空间复杂度上O(n)很容易，但是O(1)是不容易实现的）这道题一开始我的思路是分别搜索一个根的左子树和右子树，比较根和左右节点关系是否正确，后来又考虑了交换的节点在树的一侧的情况和不在同一侧的情况，最后没有AC掉这道题。这道题正确的思路应该考虑二叉树的性质，二叉树在中序遍历的时候(in order）数据的输出是从小到大的， 那么采用先序遍历二叉树的方式，就相当于顺序遍历数组发现被交换的两个数。 在写这道题的代码的时候要结合二叉树来写，熟悉二叉树中序遍历的形式，尤其是对于第一个节点不存在先前节点，深度优先搜索它的左子树为空后，第一个节点可以作为先前节点，方便后续遍历。","tags":[]},{"title":"关于树状数组","date":"2015-11-20T09:24:46.000Z","path":"2015/11/20/My-New-Post/","text":"树状数组可以用于快速从经常改变值得数组中求出某一部分的元素 用了几次树状数组，开始几次总也有不明白的地方，倒不是不会用，关键在于总感觉触摸不到精髓。 现在写下一些个人的小想法。 树状数组的核心在于标号末尾的0的个数，主要决定了控制范围，（如两个0是四个数的和，三个0是八个数的和，事实上每多出一个0的时候，控制的范围就增加了一倍，原来范围内的修改都要向计算原本和增加范围的和的数据进行更新，当然没有出现范围扩增时候也要向上更新） 对于一次求和操作，总是只能求出前若干项的和 每次有更改的时候逐级向上修改，从图中可以清楚的看出来，每当末尾多出现一个0的时候就要进行一次汇总操作 123456789void Insert(int i, int value)&#123; ++i; while (i &lt; tree.size()) &#123; tree[i] += value; i += i&amp;(-i); &#125;&#125; 其中i += i&amp;(-i);，为什么要+=后面的东西呢？前面说过除了本身，每增加一次0的时候会计算一次和（对于增加一次0其实也就是控制范围大了一倍），所以加一次自己控制的范围","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Hello World","date":"2015-11-10T10:04:57.650Z","path":"2015/11/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]